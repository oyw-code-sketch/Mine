# Edge detection
edges = cv2.Canny(blurred, 50, 150)

# Make the edges thicker but faster
kernel = np.ones((2, 2), np.uint8)  # Smaller kernel for speed
edges_dilated = cv2.dilate(edges, kernel, iterations=1)

# Using Optimized Hough Transform
lines = cv2.HoughLinesP(edges_dilated, 1, np.pi / 180, threshold=40, minLineLength=40, maxLineGap=20)

# Calculate midpoint to find line's position
avg_x.append((x1 + x2) // 2)


# Use binary threshold for faster processing instead of adaptive threshold
_, binary = cv2.threshold(blurred, 100, 255, cv2.THRESH_BINARY_INV)

# Finding Contours:
contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Calculating the Centroid of the Contour to find line's position
M = cv2.moments(largest_contour)
cx = int(M["m10"] / M["m00"])

total_frames += 1 # Count every processed frame
line_detected_frames += 1 # If a line is detected
accuracy = (line_detected_frames / total_frames) * 100 

error = cx - frame_center # cx is the detected line's horizontal center
total_deviation += abs(error) # Accumulate absolute deviation
avg_deviation = (total_deviation / line_detected_frames)

start_time = time.time()
processing_time = (time.time() - start_time) * 1000  # Convert to milliseconds
total_processing_time += processing_time
avg_processing_time = (total_processing_time / total_frames) 
